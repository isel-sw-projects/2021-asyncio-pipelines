/*
 * This Java source file was generated by the Gradle 'init' task.
 */

import AsyncFile.KotlinAppTest;
import lookwords.FileUtils;
import lookwords.FindBiggestWithParallel.*;
import lookwords.FindBiggestWordStrategies.*;
import lookwords.group.*;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.Instant;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;

import static java.util.Collections.max;
import static java.util.Comparator.comparingInt;
import static lookwords.FileUtils.FOLDER;

public class AppTest {
    static final int ITERATIONS = 5;
    static final int MIN = 5;
    static final int MAX = 10;
    private static final Logger LOGGER = Logger.getLogger(AppTest.class.getPackageName());




    public static void main(String []args){
        AppTest app = new AppTest();



        KotlinAppTest appk = new KotlinAppTest();

        appk.testMain();
        app.testGroupWords();
        app.testFindBiggestWord();

    }


    public void testGroupWords() {
        System.setProperty(
            "java.util.logging.SimpleFormatter.format",
            "%4$s %2$s %5$s%6$s%n");

        // 10000 ms Sequentially. This is the baseline.
        // testGrouping(new GroupWordsBlockingReaderInStreams(false));

        // > 15000 ms
        // testGrouping(new GroupWordsBodyPublisherInFlux());
        // testGrouping(new GroupWordsBodyPublisherInObservable());

        // 3500 ms
     // testGrouping(new GroupWordsBlockingReaderInMultiThread());
     // // 4400 ms
     // testGrouping(new GroupWordsBlockingReaderInStreams(true));

     // // Mix of Miguel RxIo library using Flow.Publisher and enhanced with Jorge Martins insights.
     // // 3400 ms without cancellation
     // // 3700 ms with support for cancellation
     // // [4100, 4800] ms through RxJava

      testGrouping(new GroupWordsBaseline());
      testGrouping(new GroupWordsRXJava());
      testGrouping(new GroupWordsInRectorCoreFlux());
      testGrouping(new GroupWordsBlockingReaderInMultiThread());
      testGrouping(new GroupWordsBlockingReaderInStreams());

     // testGrouping(new GroupWordsRxIoInAsyncQuery()); // 4200 ms sometimes 3800

      // testGroupingFindBiggest(new FindWordBaseLine());
      // testGroupingFindBiggest(new FindBiggestWordRxIoInFlux());
      // testGroupingFindBiggest(new FindBiggestWordRxIoInObservable());
      // testGroupingFindBiggest(new FindBiggestWordBlockingReaderInStreams());
      // testGroupingFindBiggest(new FindBiggestWordBlockingReaderInMultiThread());
      // testGroupingFindBiggest(new FindBiggestWordConcurrentRxIoInFlux());
      // testGroupingFindBiggest(new FindBiggestWordConcurrentRxIoInObservable());
      // testGroupingFindBiggest(new FindBiggestWordConcurrentBlockingReaderInStreams());
      // testGroupingFindBiggest(new FindWordBaseLine());

    }


    public void testFindBiggestWord() {
        System.setProperty(
                "java.util.logging.SimpleFormatter.format",
                "%4$s %2$s %5$s%6$s%n");

        // 10000 ms Sequentially. This is the baseline.
        // testGrouping(new GroupWordsBlockingReaderInStreams(false));

        // > 15000 ms
        // testGrouping(new GroupWordsBodyPublisherInFlux());
        // testGrouping(new GroupWordsBodyPublisherInObservable());

        // 3500 ms
        // testGrouping(new GroupWordsBlockingReaderInMultiThread());
        // // 4400 ms
        // testGrouping(new GroupWordsBlockingReaderInStreams(true));

        // // Mix of Miguel RxIo library using Flow.Publisher and enhanced with Jorge Martins insights.
        // // 3400 ms without cancellation
        // // 3700 ms with support for cancellation
        // // [4100, 4800] ms through RxJava

       //testGrouping(new GroupWordsBaseline());
       //testGrouping(new GroupWordsRXJava());
       //testGrouping(new GroupWordsInRectorCoreFlux());
       //testGrouping(new GroupWordsBlockingReaderInMultiThread());
       //testGrouping(new GroupWordsBlockingReaderInStreams());

        // testGrouping(new GroupWordsRxIoInAsyncQuery()); // 4200 ms sometimes 3800

         testGroupingFindBiggest(new FindWordBaseLine());
         testGroupingFindBiggest(new FindBiggestWordRxIoInFlux());
         testGroupingFindBiggest(new FindBiggestWordRxIoInObservable());
         testGroupingFindBiggest(new FindBiggestWordBlockingReaderInStreams());
         testGroupingFindBiggest(new FindBiggestWordBlockingReaderInMultiThread());
         testGroupingFindBiggest(new FindBiggestWordConcurrentRxIoInFlux());
         testGroupingFindBiggest(new FindBiggestWordConcurrentRxIoInObservable());
         testGroupingFindBiggest(new FindBiggestWordConcurrentBlockingReaderInStreams());
         testGroupingFindBiggest(new FindWordBaseLine());

    }

    static void testGrouping(GroupWords task) {
        Map<String, ? extends Number> words = perform(task);
        if(words == null) {
            LOGGER.log(Level.INFO, "NO results!");
            return;
        }
        Entry<String, ? extends Number> common = max(words.entrySet(), comparingInt(e -> e.getValue().intValue()));
        LOGGER.log(Level.INFO, () -> String.format(
            "The most common word with %d to %d chars is: %s. It occurs: %d times.%n",
            MIN,
            MAX,
            common.getKey(),
            common.getValue().intValue()
        ));
    }

    static void testGroupingFindBiggest(FindBiggestWordConcurrent task) {
        String word = performFindBiggestJava(task);
        if(word == null) {
            LOGGER.log(Level.INFO, "NO results!");
            return;
        }

        LOGGER.log(Level.INFO, () -> String.format(
                "The biggest word found is: %s. ",
                word
        ));
    }

    // returns the time between startTime and now in milliseconds
    // Changed to show only the minimal duration of all iterations
    static long between(Instant startTime) {
        return Duration.between(startTime, Instant.now()).toMillis();
    }

    public static Map<String, ? extends Number> perform(GroupWords task) {
        LOGGER.log(Level.INFO, "############ {0}", task.getClass());
        Map<String, ? extends Number> res = null;

        // Add variables to store sum and count for averaging
        long sumTime = 0;
        int count = 0;

        for (int i = 0; i < ITERATIONS; i++) { // Change to 4 iterations
            Instant startTime = Instant.now();
            res = task.words(FOLDER, MIN, MAX);
            long dur = between(startTime);
            LOGGER.log(Level.INFO, "time: {0} ms", dur);

            if (i > 0) { // Skip first iteration for averaging
                sumTime += dur;
                count++;
            }
        }

        long averageTime = count > 0 ? sumTime / count : 0; // Compute average

        LOGGER.log(Level.INFO, "=====> AVERAGE: {0} ms", averageTime);
        return res;
    }

    public static String performFindBiggestJava(FindBiggestWordConcurrent task) {
        LOGGER.log(Level.INFO, "\n############ {0}", task.getClass());
        String res = null;
        long minTime = Long.MAX_VALUE;

        // Add variables to store sum and count for averaging
        long sumTime = 0;
        int count = 0;


        for (int i = 0; i < ITERATIONS; i++) {
            Instant startTime = Instant.now();
            res = task.findBiggestWord(FOLDER);
            long dur = between(startTime);
            LOGGER.log(Level.INFO, "time: {0} ms", dur);
            if (dur < minTime) minTime = dur;



            if (i > 0) { // Skip first iteration for averaging
                sumTime += dur;
                count++;
            }
        }

        long averageTime = count > 0 ? sumTime / count : 0; // Compute average

        LOGGER.log(Level.INFO, "\n=====> AVERAGE: {0} ms", averageTime);
        LOGGER.log(Level.INFO, "=====> BEST: {0} ms\n", minTime);
        return res;
    }


}
