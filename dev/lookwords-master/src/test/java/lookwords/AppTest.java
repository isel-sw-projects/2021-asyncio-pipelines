/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package lookwords;

import lookwords.FindBiggestWithParallel.*;
import lookwords.FindBiggestWordStrategies.*;
import lookwords.group.*;
import org.junit.Test;

import java.time.Duration;
import java.time.Instant;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;

import static java.util.Collections.max;
import static java.util.Comparator.comparingInt;

public class AppTest {
    static final int ITERATIONS = 1;
    static final int MIN = 5;
    static final int MAX = 10;
    private static final String FOLDER = "gutenberg";
    private static final Logger LOGGER = Logger.getLogger(AppTest.class.getPackageName());

    @Test
    public void testMain() {
        System.setProperty(
            "java.util.logging.SimpleFormatter.format",
            "%4$s %2$s %5$s%6$s%n");

        // 10000 ms Sequentially. This is the baseline.
        // testGrouping(new GroupWordsBlockingReaderInStreams(false));

        // > 15000 ms
        // testGrouping(new GroupWordsBodyPublisherInFlux());
        // testGrouping(new GroupWordsBodyPublisherInObservable());

        // 3500 ms
     // testGrouping(new GroupWordsBlockingReaderInMultiThread());
     // // 4400 ms
     // testGrouping(new GroupWordsBlockingReaderInStreams(true));

     // // Mix of Miguel RxIo library using Flow.Publisher and enhanced with Jorge Martins insights.
     // // 3400 ms without cancellation
     // // 3700 ms with support for cancellation
     // // [4100, 4800] ms through RxJava

      //testGrouping(new GroupWordsBaseline());
      //testGrouping(new GroupWordsRxIo());
      //testGrouping(new GroupWordsRxIoInObservable());
      //testGrouping(new GroupWordsRxIoInFlux());
      //testGrouping(new GroupWordsRxIoInAsyncQuery()); // 4200 ms sometimes 3800

        testGroupingFindBiggest(new FindWordBaseLine());
        testGroupingFindBiggest(new FindBiggestWordRxIoInFlux());
        testGroupingFindBiggest(new FindBiggestWordRxIoInObservable());
        testGroupingFindBiggest(new FindBiggestWordBlockingReaderInStreams());
        testGroupingFindBiggest(new FindBiggestWordBlockingReaderInMultiThread());
        testGroupingFindBiggest(new FindBiggestWordConcurrentRxIoInFlux());
        testGroupingFindBiggest(new FindBiggestWordConcurrentRxIoInObservable());
        testGroupingFindBiggest(new FindBiggestWordConcurrentBlockingReaderInStreams());
        testGroupingFindBiggest(new FindWordBaseLine());

    }

    static void testGrouping(GroupWords task) {
        Map<String, ? extends Number> words = perform(task);
        if(words == null) {
            LOGGER.log(Level.INFO, "NO results!");
            return;
        }
        Entry<String, ? extends Number> common = max(words.entrySet(), comparingInt(e -> e.getValue().intValue()));
        LOGGER.log(Level.INFO, () -> String.format(
            "The most common word with %d to %d chars is: %s. It occurs: %d times.%n",
            MIN,
            MAX,
            common.getKey(),
            common.getValue().intValue()
        ));
    }

    static void testGroupingFindBiggest(FindBiggestWordConcurrent task) {
        String word = performFindBiggestJava(task);
        if(word == null) {
            LOGGER.log(Level.INFO, "NO results!");
            return;
        }

        LOGGER.log(Level.INFO, () -> String.format(
                "The biggest word found is: %s. ",
                word
        ));
    }

    // returns the time between startTime and now in milliseconds
    // Changed to show only the minimal duration of all iterations
    static long between(Instant startTime) {
        return Duration.between(startTime, Instant.now()).toMillis();
    }

    public static Map<String, ? extends Number> perform(GroupWords task) {
        LOGGER.log(Level.INFO, "############ {0}", task.getClass());
        Map<String, ? extends Number> res = null;
        long minTime = Long.MAX_VALUE;
        for (int i = 0; i < ITERATIONS; i++) {
            Instant startTime = Instant.now();
            res = task.words(FOLDER, MIN, MAX);
            long dur = between(startTime);
            LOGGER.log(Level.INFO, "time: {0} ms", dur);
            if (dur < minTime) minTime = dur;

        }
        LOGGER.log(Level.INFO, "=====> BEST: {0} ms", minTime);
        return res;
    }

    public static String performFindBiggestJava(FindBiggestWordConcurrent task) {
        LOGGER.log(Level.INFO, "\n############ {0}", task.getClass());
        String res = null;
        long minTime = Long.MAX_VALUE;
        for (int i = 0; i < ITERATIONS; i++) {
            Instant startTime = Instant.now();
            res = task.findBiggestWord(FOLDER);
            long dur = between(startTime);
            LOGGER.log(Level.INFO, "time: {0} ms", dur);
            if (dur < minTime) minTime = dur;

        }
        LOGGER.log(Level.INFO, "=====> BEST: {0} ms", minTime);
        return res;
    }


}
