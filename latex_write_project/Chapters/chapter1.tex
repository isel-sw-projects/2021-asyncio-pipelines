% 
%  chapter1.tex
%  ThesisISEL
%  
%  Created by Matilde Pós-de-Mina Pato on 2012/10/09.
%
\chapter{Introduction}
\label{cha:introduction}


As state-of-the-art non-blocking IO programming tools and technologies continue to evolve, new asynchronous idioms emerge across different programming platforms. Examples of these include Dotnet Async Enumerables \cite{DOTNET_ASYNC_ENUM}, JS asynchronous generators \cite{JS_ASYNC_GENERATOR}, Kotlin Flow \cite{KOTLIN_FLOW}, among others.

Simultaneously, some idioms provide pipe lining API´s referred for example in \cite{FOWLER} that allow developers to build queries over sequences of data elements. This pipeline refers to a series of operations applied to a sequence of elements where each operation in the pipeline takes the output of the previous operation as input. A sequence pipeline with asynchronous data processing may be also denoted as reactive stream pipeline.

The research work that I describe in this dissertation aims to analyze what are the intrinsic overheads behind a reactive stream pipeline processing. While there are advantages regarding their conciseness, expressiveness, and readability, will these pipelines incur any overhead?

To answer this question we will analyze the behavior of different reactive stream pipelines technologies dealing non-blocking IO.

While non-blocking IO pipe lining enabling technologies, allows programmers to exploit concurrency without explicitly managing threads, it introduces new challenges and potential performance bottlenecks. The seamless integration of non-blocking IO with reactive stream pipelines presents a complex interplay of factors that may impact performance and resource utilization. 

This dissertation aims, to retrieve performance metrics in several technologies and discuss how these technologies behave in different use cases.

\section{Motivation}
\label{sec:motivation}

Reactive stream pipelines, it's a  concept behind several powerful tools that allows the orchestration of a series of operations on a live feed of sequence of elements in continuous non-blocking IO operations. The ability to perform asynchronous data processing through these pipelines provides developers with a concise, expressive, and readable way to handle complex tasks.

However, with these benefits come potential challenges. The integration of non-blocking IO with reactive stream pipelines introduces a complex interplay of factors that may significantly impact performance and resource utilization. While the industry is rapidly adopting these idioms for their expressiveness and ease of use, there is a growing need to understand the underlying overhead and bottlenecks. Misunderstanding or overlooking these aspects can lead to inefficient code, wasted resources, and ultimately a poor user experience.

Moreover, the variety of technologies offering reactive stream pipeline processing adds another layer of complexity. Different approaches may behave differently in various use cases, leading to uncertainty when selecting the right technology for a specific project. Understanding how these technologies perform in different scenarios is vital for informed decision-making and effective utilization.

This work aims to provide a clear picture of how and when to use each technology and strategy, along with an understanding of their respective benefits and drawbacks in comparison to one another.


\section{Goals}
\label{sec:goals}
This research is guided by the following central objectives:

\begin{enumerate}
\item \textbf{Non-blocking IO}: Investigate state-of-the-arts idioms and technologies that enable processing in non-blocking IO use cases.

\item \textbf{Baseline Behavior Analysis}: Analyze the behavior of a baseline approach, for example, a piece of code that makes no use of any pipeline of operations, the logic is made through direct implementation of algorithms using non-abstract programming. Understanding the trade-offs of such an approach, including verbosity, complexity, and maintainability, against performance benefits.

\item \textbf{Technology Comparison}: Evaluate and contrast various idioms and technologies that take advantage of non-blocking IO, focusing on how different paradigms (e.g., pull vs. push) concepts and how they perform under various conditions.

\item \textbf{Reactive Streams Technologies}: Investigate the practical implementation of reactive stream pipelines using different technologies.

\end{enumerate}

We expect that a baseline approach without the use of any pipeline technology, perform better than any other alternative, despite its verbosity, complexity, and difficult maintainability.

On the other side, we would like to understand which approach that provides an asynchronous pipeline API that performs better, for example in the same language depending on the task.

Lastly, this work aims to have results and conclusions from different programming languages implementations of asynchronous pipelining Tecnhologies. This is crucial to understand, for example, if the same technology e.g. \textit{Reactor} performance differs depending on the programming language; on the other side, its interisting to know too, if any programming enviroment performs significantly better than the others in this particular set of   JAVA, Kotlin, C\#, and JavaScript. 

We aim to observe how performance behaves in these different scenarios to uncover the distinct advantages and disadvantages of each approach. This in-depth examination is intended to culminate in practical conclusions that can guide informed decision-making in future projects.

\section{Outline}
\label{sec:outline}

This dissertation is organized into distinct chapters that systematically guide the reader through the research, concepts, methodologies, and findings:

\begin{itemize}
\item \textbf{Chapter 1: Introduction} - This initial chapter provides an overview of the research context, the motivation behind the study, the primary goals, and the approach taken.

\item \textbf{Chapter 2:State-of-the-Art} - Here, we explore the foundational concepts related to reactive stream pipelines and provide a comprehensive review of the existing technologies and strategies in JAVA (including Kotlin), C\#, and Javascript. The chapter aims to establish the current landscape and set the stage for our research.

\item \textbf{Chapter 3: Methodology} - In this chapter, the research design, including the selection of technologies, experimental setup, and methodologies used to gather and analyze data, will be detailed. The rationale behind these choices will also be explained.

\item \textbf{Chapter 4: Detailed Analysis and Comparison of Results} - This chapter presents the results obtained from the implementations and provides a thorough analysis and discussion of the findings. It includes comparisons between various reactive technologies and other strategies, and how they perform against baseline approaches.

\item \textbf{Chapter 5: Conclusions and Future Directions} - The final chapter will summarize the main insights derived from the study, highlight the contributions made, discuss the limitations, and propose directions for future research.

\end{itemize}

