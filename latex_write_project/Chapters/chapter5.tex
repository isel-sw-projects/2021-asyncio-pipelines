\chapter{Conclusions and Future Directions}

\section{Main Conclusions}

The analysis of reactive streams programming and pipelining technologies throughout this thesis highlights their substantial benefits in terms of user-friendliness and maintenance simplicity. Nonetheless, these technologies also present certain drawbacks that must be carefully considered in the context of specific application requirements and desired outcomes.

For systems demanding high performance and robustness, a baseline-like approach, which allows for custom optimization, might be ideal. Conversely, for rapid development with satisfactory performance and easier maintenance, tools like RxJava and .NET's AsyncEnumerable provide valuable solutions. The choice largely depends on the project's long-term objectives and operational context. For example, high-frequency trading systems require the raw speed and low latency that finely tuned baseline systems provide. In scenarios where time-to-market is crucial, the productivity benefits of higher-level frameworks may outweigh their performance costs.

While baseline approaches generally performed better in specific algorithms, the practicality of using advanced frameworks like RxJava or .NET's AsyncEnumerable in enterprise environments cannot be overlooked. They facilitate rapid development and easier maintenance, which are often prioritized over minor performance gains in many professional settings.

However, a notable observation from the results is that the programming language, frameworks, and virtual environments running the algorithms have a significant impact on performance. For instance, Java outperformed .NET and JavaScript solutions across baseline, reactive streams frameworks, and parallelization strategies, despite the algorithms and implementations being nearly identical.

Another surprise is that several parallelization implementations using blocking I/O showed very competitive performances, albeit with higher resource usage. This indicates that parallelization can be an effective strategy, even with blocking I/O, under certain conditions.

In conclusion, the choice of technology stack and environment can greatly influence the performance and development efficiency of a project. Therefore, careful consideration of these factors is essential for achieving the desired balance between performance, maintainability, and development speed.


\section{Future Work and Final Thoughts}

Looking ahead, there are several promising directions for future research:

\begin{itemize}
    \item \textbf{Exploration of Emerging Frameworks:} Continual investigation into new and emerging frameworks can provide insights into more efficient and scalable solutions for managing asynchronous tasks.
    \item \textbf{Enhancement of Benchmarking Tools:} Developing and utilizing more accurate and comprehensive benchmarking tools to measure the performance, scalability, and reliability of asynchronous technologies across different scenarios will be crucial. This enhancement will allow for deeper insights into both established and emerging technologies and strategies.
    \item \textbf{Development of debugging tools:} Asynchronous code debugging can be challenging due to its non-linear execution flow. Improved debugging tools need to effectively manage asynchronous stack traces and provide clear insights into the state of operations at any given moment. Tools that offer visualizations of code execution timelines and interaction patterns can simplify the debugging process and enhance understanding.
\end{itemize}

In our final thoughts, this work has clearly demonstrated that different approaches significantly impact the effectiveness of solutions. In today's digital environment, dominated by live data streaming, the method of handling data asynchronously is more crucial than ever. It has been shown that adhering to robust programming practices and selecting the appropriate tools and strategies, based on best practices, are critical.
\clearpage


